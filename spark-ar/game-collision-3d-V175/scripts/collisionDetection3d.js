
// 3d collsiion detection using cannonjs code generated by vivekcse
// lets start

const Scene = require('Scene');
const Time = require('Time')
const CANNON = require('cannon');
const d = require('Diagnostics');
const Animation = require('Animation');


let gamescore = 0;

(async function () {

  //initialising canon physics world
  const world = new CANNON.World();
  world.gravity.set(0, -10, 0);
  const fixedTimeStep = 1.0 / 30.0;
  const maxSubSteps = 3;
  const timeInterval = 30;
  let lastTime;
  const xAxis = new CANNON.Vec3(1, 0, 0);
  const yAxis = new CANNON.Vec3(0, 1, 0);
  const zAxis = new CANNON.Vec3(0, 0, 1);

  const gameScoreText = await Scene.root.findFirst('gameScoreText');
  const receiver = await Scene.root.findFirst('receiverItem');
  const gameItem = await Scene.root.findFirst('gameItem');
  const ground = await Scene.root.findFirst('ground');

  // initialising ground physics
  const groundProps = {
    mass: 0,
    // position: new CANNON.Vec3(0, -0.1, 0),
    shape: new CANNON.Plane(),
  }
  const groundBody = new CANNON.Body(groundProps);
  const angle = -Math.PI / 2;
  groundBody.quaternion.setFromAxisAngle(xAxis, angle);
  ground.transform.x = groundBody.position.x;
  ground.transform.y = groundBody.position.y;
  ground.transform.z = groundBody.position.z;
  world.addBody(groundBody);

  // reciver physics
  const receiverSize = new CANNON.Vec3(.025 * 1, .025 * 1, .025 * 1);
  const receiverProps = {
    position: new CANNON.Vec3(0, 0, 0),
    mass: 1,
    boxsize: receiverSize,
    shape: new CANNON.Box(receiverSize),
  }
  const receiverBody = new CANNON.Body(receiverProps);
  world.addBody(receiverBody);

  //gameItem physics
  const gameItemSize = new CANNON.Vec3(.025 * 1, .025 * 1, .025 * 1);
  const gameItemProps = {
    position: new CANNON.Vec3(0, 0, 1),
    mass: 1,
    boxsize: gameItemSize,
    shape: new CANNON.Box(gameItemSize),
  }
  const gameItemBody = new CANNON.Body(gameItemProps);
  world.addBody(gameItemBody);

  // initialising interval for game
  Time.setInterval(function (time) {
    if (lastTime !== undefined) {
      let dt = (time - lastTime) / 1000;
      world.step(fixedTimeStep, dt, maxSubSteps);

      // making physics body to item position
      receiverBody.position.x = receiver.worldTransform.x.pinLastValue();
      receiverBody.position.y = receiver.worldTransform.y.pinLastValue();
      receiverBody.position.z = receiver.worldTransform.z.pinLastValue();

      gameItemBody.position.x = gameItem.worldTransform.x.pinLastValue();
      gameItemBody.position.y = gameItem.worldTransform.y.pinLastValue();
      gameItemBody.position.z = gameItem.worldTransform.z.pinLastValue();

      // collision detetcion
      bodiesAreInContact(receiverBody, gameItemBody)
    }
    lastTime = time
  }, timeInterval);

  // collision detectin function
  function bodiesAreInContact(bodyA, bodyB) {

    for (var i = 0; i < world.contacts.length; i++) {
      var c = world.contacts[i];

      if ((c.bi === bodyA && c.bj === bodyB) || (c.bi === bodyB && c.bj === bodyA)) {
        gamescore += 1;
        gameScoreText.text = gamescore.toString();
      }
    }
    return false;
  }

})();

function quatToEuler(quat) {
  const q0 = quat.x;
  const q1 = quat.y;
  const q2 = quat.z;
  const q3 = quat.w;

  const Rx = Math.atan2(2 * (q0 * q1 + q2 * q3), 1 - (2 * (q1 * q1 + q2 * q2)));
  const Ry = Math.asin(2 * (q0 * q2 - q3 * q1));
  const Rz = Math.atan2(2 * (q0 * q3 + q1 * q2), 1 - (2 * (q2 * q2 + q3 * q3)));

  const euler = { x: Rx, y: Ry, z: Rz };

  return euler;
}

// making real life body on physics body
// receiver.transform.x = receiverBody.position.x;
// receiver.transform.y = receiverBody.position.y;
// receiver.transform.z = receiverBody.position.z;

// gameItem.transform.x = gameItemBody.position.x;
// gameItem.transform.y = gameItemBody.position.y;
// gameItem.transform.z = gameItemBody.position.z;

// making physics body to item local position
// receiverBody.position.x = receiver.transform.x.pinLastValue();
// receiverBody.position.y = receiver.transform.y.pinLastValue();
// receiverBody.position.z = receiver.transform.z.pinLastValue();

// gameItemBody.position.x = gameItem.transform.x.pinLastValue();
// gameItemBody.position.y = gameItem.transform.y.pinLastValue();
// gameItemBody.position.z = gameItem.transform.z.pinLastValue();